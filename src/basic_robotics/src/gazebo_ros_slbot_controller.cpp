/*
 * User defined Gazebo Plugin for control of a Single Link Robot
 * This is the source file (definitions)
 * 
 * This file is the header file for a Gazebo plugin, made for
 * controlling the single link robot in Tutorial 5. Most of the
 * inference can be derived from template [1] as well as the
 * header [2] and source code [3] of a simple but elaborate
 * plugin: skid_steer_drive. The source code of the template [4]
 * can also be referred to. See the Gazebo API reference [5] for
 * more information on header files and contents.
 * 
 * // TODO: PID Controller, set gains through service callback
 *  and set the setpoint through subscription to a ROS Topic.
 *  Implement the setpoint (target) subscriber first.
 * 
 * 
 * [1]: https://github.com/ros-simulation/gazebo_ros_pkgs/blob/kinetic-devel/gazebo_plugins/include/gazebo_plugins/gazebo_ros_template.h
 * [2]: https://github.com/ros-simulation/gazebo_ros_pkgs/blob/kinetic-devel/gazebo_plugins/include/gazebo_plugins/gazebo_ros_skid_steer_drive.h
 * [3]: https://github.com/ros-simulation/gazebo_ros_pkgs/blob/kinetic-devel/gazebo_plugins/src/gazebo_ros_skid_steer_drive.cpp
 * [4]: https://github.com/ros-simulation/gazebo_ros_pkgs/blob/kinetic-devel/gazebo_plugins/src/gazebo_ros_template.cpp
 * [5]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/index.html
 * 
 */

// Include the header file
#include "gazebo_plugins/gazebo_ros_slbot_controller.h"
// Header file for publishing sensor_msgs/JointState
#include <sensor_msgs/JointState.h>

using namespace std;

namespace gazebo {
    // Register this plugin
    /*
     * Registration links the libraries so that the Gazebo node
     * can communicate with this plugin at runtime
     * 
     * Ref: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/Plugin_8hh.html#a385cb7e63b208e5e0b321bf673f6d59f
     */
    GZ_REGISTER_MODEL_PLUGIN(GazeboRosSlbotController);

    // Constructor
    GazeboRosSlbotController::GazeboRosSlbotController() {
    }

    // Destructor
    GazeboRosSlbotController::~GazeboRosSlbotController() {
        // Delete NodeHandler pointer
        delete this->_nh;
    }

    // Load the controller
    /*
     * This is a function that the ModelPlugin object will
     * call. It's a function that every plugin has to 
     * implement [1].
     * 
     * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1ModelPlugin.html#a234fed4495e7fd0c3e1bd88077dd7a8e
     */
    void GazeboRosSlbotController::Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf) {
        // Check if ROS is initialized
        if (!ros::isInitialized()) {
            ROS_FATAL_STREAM_NAMED("slbot", "ROS is not initialized." 
                << "Load 'libgazebo_ros_api_plugin.so' in the gazebo_ros package");
            return;
        }
        // Get pointers to parent and world
        /*
         * The parent is the ModelPtr (pointer to the
         * model in Gazebo). The world is the WorldPtr
         * (pointer to the Gazebo world). The parent
         * is passed to the Load function [1]. More
         * about the Model class [2]. About the
         * GetWorld function [3] and about World [4]
         * 
         * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1ModelPlugin.html#a234fed4495e7fd0c3e1bd88077dd7a8e
         * [2]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Model.html
         * [3]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Base.html#a9e27deb7b7cc4bf50f8625edcb9c38ad
         * [4]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1World.html
         */
        this->parent = _parent;
        this->world = _parent->GetWorld();
        // ---- Begin: Parse the SDF ----
        // Read Namespace
        this->robot_namespace = "";
        // Check if SDF has element
        /*
         * Check the SDF tree (the same XML that is
         * generated by processing the XACRO file)
         * and verify if a <robotNamespace> is passed
         * to the plugin. We will later get its value
         * if it exists
         * 
         * Ref: https://osrf-distributions.s3.amazonaws.com/sdformat/api/dev/classsdf_1_1v11_1_1Element.html#a488d15becfe47c362665f82a95d933ca
         */
        if (!_sdf->HasElement("robotNamespace")) {  // Element doesn't exist / not passed
            ROS_INFO_NAMED("slbot", "Robot namespace defaults to \"%s\"", this->robot_namespace.c_str());
        } else {
            // Get value, as it exists
            /*
             * Get the value from the element. For this
             * we first get the pointer to the element
             * we need using GetElement [1] and then get
             * the value in a particular type using the
             * Get [2] function. There is also a form
             * that allows us to use a default value if
             * the element doesn't exist [3].
             * 
             * [1]: https://osrf-distributions.s3.amazonaws.com/sdformat/api/dev/classsdf_1_1v11_1_1Element.html#a4cf1ee6d6b0cec87d448e4a5968c4307
             * [2]: https://osrf-distributions.s3.amazonaws.com/sdformat/api/dev/group__sdf.html#gaeef13b739dc0a6d37cc49980ff5b9464
             * [3]: https://osrf-distributions.s3.amazonaws.com/sdformat/api/dev/group__sdf.html#gad83fd95a22a2b2d25a4b364a5afb3ecc
             */
            this->robot_namespace = _sdf->GetElement("robotNamespace")->Get<string>() + "/";
            ROS_INFO_NAMED("slbot", "Robot namespace set to \"%s\"", this->robot_namespace.c_str());
        }
        // Joint name
        this->params.joint_name = "joint1";
        if (!_sdf->HasElement("robotJoint")) {
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) missing <robotJoint>. Defaults to %s",
                this->robot_namespace.c_str(), this->params.joint_name.c_str());
        } else {
            this->params.joint_name = _sdf->GetElement("robotJoint")->Get<string>();
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) joint name set to \"%s\"",
                this->robot_namespace.c_str(), this->params.joint_name.c_str());
        }
        // Joint state (topic name for message type sensor_msgs/JointState)
        this->params.js_topic = "joint_states";
        if (!_sdf->HasElement("jointStateTopic")) {
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) missing <jointStateTopic>. Defaults to \"%s\"",
                this->robot_namespace.c_str(), this->params.js_topic.c_str());
        } else {
            this->params.js_topic = _sdf->GetElement("jointStateTopic")->Get<string>();
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) joint state topic set to \"%s\"",
                this->robot_namespace.c_str(), this->params.js_topic.c_str());
        }
        this->params.js_msg.header.seq = 0; // Starting message
        // Rate (for the load loop)
        this->params.rate_hz = 100;
        if (!_sdf->HasElement("rate")) {
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) missing <rate>. Defaults to %f",
                this->robot_namespace.c_str(), this->params.rate_hz);
        } else {
            this->params.rate_hz = _sdf->GetElement("rate")->Get<double>();
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) rate set to %f Hz",
                this->robot_namespace.c_str(), this->params.rate_hz);
        }
        this->params.update_period_sec = 1.0 / this->params.rate_hz;
        this->params.last_update_time = this->world->SimTime(); // Current time for last update
        // ---- End: Parse the SDF ----

        // ---- Begin: Setup things specific to this plugin ----
        // NodeHandler (in the namespace)
        this->_nh = new ros::NodeHandle(this->robot_namespace);
        // Get the Joint pointer (to interact with the joint)
        /*
         * The Joint class is the base class for all kinds
         * of joints in Gazebo [1]. The JointPtr (joint
         * pointer) is returned through the ModelPtr passed
         * to this function (which is this->parent) [2].
         * 
         * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Joint.html
         * [2]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Model.html#a8493e43d4ddbc0e381a6771402cec6f0
         */
        this->joint = this->parent->GetJoint(this->params.joint_name);
        // Set up publisher to publish joint angles from model
        this->joint_angle_publisher_ = this->_nh->advertise<sensor_msgs::JointState>(
            this->params.js_topic, 1);
        // Set the update function
        /*
         * We basically want to run a function every
         * iteration of the simulation. This means that
         * we want to bind a function to an event (update
         * world). This is done using [1]. You can get the
         * inference from [2]
         * 
         * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1event_1_1Events.html#a0c8c7e6a33ad46f8be45b6a33d279fdc
         * [2]: http://gazebosim.org/tutorials?tut=plugins_model&cat=write_plugin#Code
         */
        this->update_connection = event::Events::ConnectWorldUpdateBegin(
            boost::bind(&GazeboRosSlbotController::UpdateChild, this)); // Bind this->UpdateChild
        // ---- End: Setup things specific to this plugin ----
    }

    // Update child
    void GazeboRosSlbotController::UpdateChild() {
        // Get the current simulation time
        /*
         * This returns the time since the start
         * of simulation. Use SimTime to get the
         * time since the start of simulation [1].
         * Use common::Time::GetWallTime for real
         * world time [2].
         * 
         * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1World.html#ae8de96cafe2517f4285edb421ab130e7
         * [2]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1common_1_1Time.html#aa8e053e14c4d1170ef45e5d9e0a26d10
         */
        common::Time curr_time = this->world->SimTime();
        if ((curr_time - this->params.last_update_time).Double() > this->params.update_period_sec) {
            // ---- Update the child (according to the rate) ----
            // Get joint angle
            /*
             * Get the joint angle in Gazebo simulation.
             * This is retrieved from the JointPtr which
             * was obtained from ModelPtr. Position function
             * gets the floating point value [1], which is
             * rotation in radians or translation in meters
             * 
             * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Joint.html#a1e48139677005b6702c8c00832710da2
             */
            double jangle_rad = this->joint->Position(0);
            // Update the publishing message
            this->params.js_msg.header.seq += 1;
            this->params.js_msg.header.stamp = ros::Time::now();    // Messages in ROS time
            this->params.js_msg.name.clear();
            this->params.js_msg.name.push_back(this->params.joint_name);
            this->params.js_msg.position.clear();
            this->params.js_msg.position.push_back(jangle_rad);
            // Publish the message (for joint angle)
            this->joint_angle_publisher_.publish(this->params.js_msg);  // Publish
            // ---- Child updated ----
            // Update the last updated time
            this->params.last_update_time += common::Time(this->params.update_period_sec);
        }
    }
}
