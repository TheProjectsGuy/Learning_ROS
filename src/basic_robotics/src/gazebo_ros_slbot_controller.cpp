/*
 * User defined Gazebo Plugin for control of a Single Link Robot
 * This is the source file (definitions)
 * 
 * This file is the header file for a Gazebo plugin, made for
 * controlling the single link robot in Tutorial 5. Most of the
 * inference can be derived from template [1] as well as the
 * header [2] and source code [3] of a simple but elaborate
 * plugin: skid_steer_drive. The source code of the template [4]
 * can also be referred to. See the Gazebo API reference [5] for
 * more information on header files and contents.
 * 
 * // TODO: PID Controller, set gains through service callback
 * 
 * 
 * [1]: https://github.com/ros-simulation/gazebo_ros_pkgs/blob/kinetic-devel/gazebo_plugins/include/gazebo_plugins/gazebo_ros_template.h
 * [2]: https://github.com/ros-simulation/gazebo_ros_pkgs/blob/kinetic-devel/gazebo_plugins/include/gazebo_plugins/gazebo_ros_skid_steer_drive.h
 * [3]: https://github.com/ros-simulation/gazebo_ros_pkgs/blob/kinetic-devel/gazebo_plugins/src/gazebo_ros_skid_steer_drive.cpp
 * [4]: https://github.com/ros-simulation/gazebo_ros_pkgs/blob/kinetic-devel/gazebo_plugins/src/gazebo_ros_template.cpp
 * [5]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/index.html
 * 
 */

// Include the header file
#include "gazebo_plugins/gazebo_ros_slbot_controller.h"
// Header file for publishing sensor_msgs/JointState
#include <sensor_msgs/JointState.h>

#define DEG_TO_RAD(x) (((M_PI)/(180.0))*(x))

using namespace std;

namespace gazebo {
    // Register this plugin
    /*
     * Registration links the libraries so that the Gazebo node
     * can communicate with this plugin at runtime
     * 
     * Ref: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/Plugin_8hh.html#a385cb7e63b208e5e0b321bf673f6d59f
     */
    GZ_REGISTER_MODEL_PLUGIN(GazeboRosSlbotController);

    // Constructor
    GazeboRosSlbotController::GazeboRosSlbotController() {
        this->is_alive = true;
        // Initial controller properties
        this->controller.kp = 10.0;
        this->controller.kd = 2.0;
        this->controller.desired_pos = DEG_TO_RAD(0.0);    // Set point to 0 in the beginning
    }

    // Destructor
    GazeboRosSlbotController::~GazeboRosSlbotController() {
        this->is_alive = false;
        // Clear the disable the callback queue
        /*
         * Clears all callbacks in the queue [1] and then
         * disable the queue (so that more callbacks are 
         * no longer possible) [2]
         * 
         * [1]: http://docs.ros.org/en/latest/api/roscpp/html/classros_1_1CallbackQueue.html#ab960789600b6a6d775249347c234019a
         * [2]: http://docs.ros.org/en/latest/api/roscpp/html/classros_1_1CallbackQueue.html#acca1c15e2498f0020ec1afc8b6b1709e
         */
        this->queue_.clear();
        this->queue_.disable();
        // Delete NodeHandler pointer
        delete this->_nh;
    }

    // Load the controller
    /*
     * This is a function that the ModelPlugin object will
     * call. It's a function that every plugin has to 
     * implement [1].
     * 
     * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1ModelPlugin.html#a234fed4495e7fd0c3e1bd88077dd7a8e
     */
    void GazeboRosSlbotController::Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf) {
        // Check if ROS is initialized
        if (!ros::isInitialized()) {
            ROS_FATAL_STREAM_NAMED("slbot", "ROS is not initialized." 
                << "Load 'libgazebo_ros_api_plugin.so' in the gazebo_ros package");
            return;
        }
        // Get pointers to parent and world
        /*
         * The parent is the ModelPtr (pointer to the
         * model in Gazebo). The world is the WorldPtr
         * (pointer to the Gazebo world). The parent
         * is passed to the Load function [1]. More
         * about the Model class [2]. About the
         * GetWorld function [3] and about World [4]
         * 
         * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1ModelPlugin.html#a234fed4495e7fd0c3e1bd88077dd7a8e
         * [2]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Model.html
         * [3]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Base.html#a9e27deb7b7cc4bf50f8625edcb9c38ad
         * [4]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1World.html
         */
        this->parent = _parent;
        this->world = _parent->GetWorld();
        // ---- Begin: Parse the SDF ----
        // Read Namespace
        this->robot_namespace = "";
        // Check if SDF has element
        /*
         * Check the SDF tree (the same XML that is
         * generated by processing the XACRO file)
         * and verify if a <robotNamespace> is passed
         * to the plugin. We will later get its value
         * if it exists
         * 
         * Ref: https://osrf-distributions.s3.amazonaws.com/sdformat/api/dev/classsdf_1_1v11_1_1Element.html#a488d15becfe47c362665f82a95d933ca
         */
        if (!_sdf->HasElement("robotNamespace")) {  // Element doesn't exist / not passed
            ROS_INFO_NAMED("slbot", "Robot namespace defaults to \"%s\"", this->robot_namespace.c_str());
        } else {
            // Get value, as it exists
            /*
             * Get the value from the element. For this
             * we first get the pointer to the element
             * we need using GetElement [1] and then get
             * the value in a particular type using the
             * Get [2] function. There is also a form
             * that allows us to use a default value if
             * the element doesn't exist [3].
             * 
             * [1]: https://osrf-distributions.s3.amazonaws.com/sdformat/api/dev/classsdf_1_1v11_1_1Element.html#a4cf1ee6d6b0cec87d448e4a5968c4307
             * [2]: https://osrf-distributions.s3.amazonaws.com/sdformat/api/dev/group__sdf.html#gaeef13b739dc0a6d37cc49980ff5b9464
             * [3]: https://osrf-distributions.s3.amazonaws.com/sdformat/api/dev/group__sdf.html#gad83fd95a22a2b2d25a4b364a5afb3ecc
             */
            this->robot_namespace = _sdf->GetElement("robotNamespace")->Get<string>() + "/";
            ROS_INFO_NAMED("slbot", "Robot namespace set to \"%s\"", this->robot_namespace.c_str());
        }
        // Joint name
        this->params.joint_name = "joint1";
        if (!_sdf->HasElement("robotJoint")) {
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) missing <robotJoint>. Defaults to %s",
                this->robot_namespace.c_str(), this->params.joint_name.c_str());
        } else {
            this->params.joint_name = _sdf->GetElement("robotJoint")->Get<string>();
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) joint name set to \"%s\"",
                this->robot_namespace.c_str(), this->params.joint_name.c_str());
        }
        // Joint state (topic name for message type sensor_msgs/JointState)
        this->params.js_topic = "joint_states";
        if (!_sdf->HasElement("jointStateTopic")) {
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) missing <jointStateTopic>. Defaults to \"%s\"",
                this->robot_namespace.c_str(), this->params.js_topic.c_str());
        } else {
            this->params.js_topic = _sdf->GetElement("jointStateTopic")->Get<string>();
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) joint state topic set to \"%s\"",
                this->robot_namespace.c_str(), this->params.js_topic.c_str());
        }
        this->params.js_msg.header.seq = 0; // Starting message
        // Rate (for the load loop)
        this->params.rate_hz = 100;
        if (!_sdf->HasElement("rate")) {
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) missing <rate>. Defaults to %f",
                this->robot_namespace.c_str(), this->params.rate_hz);
        } else {
            this->params.rate_hz = _sdf->GetElement("rate")->Get<double>();
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) rate set to %f Hz",
                this->robot_namespace.c_str(), this->params.rate_hz);
        }
        this->params.update_period_sec = 1.0 / this->params.rate_hz;
        this->params.last_update_time = this->world->SimTime(); // Current time for last update
        // Joint target (topic to subscribe)
        this->params.jtarget_topic = "cmd_position";
        if (!_sdf->HasElement("jointTargetTopic")) {
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) missing <jointTargetTopic>. Defaults to \"%s\"",
                this->robot_namespace.c_str(), this->params.jtarget_topic.c_str());
        } else {
            this->params.jtarget_topic = _sdf->GetElement("jointTargetTopic")->Get<string>();
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) joint target topic set to \"%s\"",
                this->robot_namespace.c_str(), this->params.jtarget_topic.c_str());
        }
        // Controller gains
        this->params.cgains_srv = "set_pid_srv";
        if (!_sdf->HasElement("controllerService")) {
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) missing <controllerService>. Defaults to \"%s\"",
                this->robot_namespace.c_str(), this->params.cgains_srv.c_str());
        } else {
            this->params.cgains_srv = _sdf->GetElement("controllerService")->Get<string>();
            ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) PID controller service server set to \"%s\"",
                this->robot_namespace.c_str(), this->params.cgains_srv.c_str());
        }
        // ---- End: Parse the SDF ----

        // ---- Begin: Setup things specific to this plugin ----
        // NodeHandler (in the namespace)
        this->_nh = new ros::NodeHandle(this->robot_namespace);
        // Get the Joint pointer (to interact with the joint)
        /*
         * The Joint class is the base class for all kinds
         * of joints in Gazebo [1]. The JointPtr (joint
         * pointer) is returned through the ModelPtr passed
         * to this function (which is this->parent) [2].
         * 
         * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Joint.html
         * [2]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Model.html#a8493e43d4ddbc0e381a6771402cec6f0
         */
        this->joint = this->parent->GetJoint(this->params.joint_name);
        // Set up publisher to publish joint angles from model
        this->joint_angle_publisher_ = this->_nh->advertise<sensor_msgs::JointState>(
            this->params.js_topic, 1);
        // Subscriber for new joint positions
        /*
         * Here, we'll first create a SubscribeOptions object [1]
         * which will directly be passed to the subscribe method
         * of the node handler. The SubscribeOptions is created
         * using a static 'create' method [2]. The first argument
         * is the topic name, second is queue size, third is the 
         * callback. Fourth is the tracked object (if it is destroyed,
         * the callback won't execute), set to Void here (unused).
         * The fifth argument is the callback queue pointer. The
         * subscriber object is just given the options [3].
         * 
         * [1]: http://docs.ros.org/en/latest/api/roscpp/html/structros_1_1SubscribeOptions.html
         * [2]: http://docs.ros.org/en/latest/api/roscpp/html/structros_1_1SubscribeOptions.html#a502d3ce4b47623bb6e3834f6748e4074
         * [3]: http://docs.ros.org/en/latest/api/roscpp/html/classros_1_1NodeHandle.html#a3b8e4b07d397119cd5c5e4439b170cbc
         */
        ros::SubscribeOptions so = ros::SubscribeOptions::create<std_msgs::Float64>(this->params.jtarget_topic, 1,
            boost::bind(&GazeboRosSlbotController::SetNewTarget, this, _1), ros::VoidPtr(), &this->queue_);
        this->new_joint_pos_subscriber_ = this->_nh->subscribe(so);
        // Advertise the service server
        /*
         * Here, an AdvertiseServiceOptions object is used [1].
         * The create method is used to generate this object [2].
         * The advertiseService function is then passed this
         * object [3]. The first argument is the service name,
         * the second is the callback function, third is the
         * tracked object and the fourth is the callback queue
         * pointer.
         * 
         * [1]: http://docs.ros.org/en/latest/api/roscpp/html/structros_1_1AdvertiseServiceOptions.html
         * [2]: http://docs.ros.org/en/latest/api/roscpp/html/structros_1_1AdvertiseServiceOptions.html#a3cb2c69387686bc2c8a80c0a98fa0720
         * [3]: http://docs.ros.org/en/latest/api/roscpp/html/classros_1_1NodeHandle.html#ae659319707eb40e8ef302763f7d632da
         */
        ros::AdvertiseServiceOptions aso = ros::AdvertiseServiceOptions::create<control_toolbox::SetPidGains>(
            this->params.cgains_srv, boost::bind(&GazeboRosSlbotController::SetController, this, _1, _2),
            ros::VoidPtr(), &this->queue_);
        this->set_pid_gains_server_ = this->_nh->advertiseService(aso);
        // Start callback thread
        /*
         * A thread that is run in parallel. This thread only listens
         * to callbacks for this plugin. Boost library's thread [1]
         * implementation is used here. The QueueThread method will
         * be run in a parallel thread.
         * 
         * [1]: https://www.boost.org/doc/libs/1_76_0/doc/html/thread.html
         */
        this->callback_queue_thread_ = boost::thread(
            boost::bind(&GazeboRosSlbotController::QueueThread, this));
        // Set the update function
        /*
         * We basically want to run a function every
         * iteration of the simulation. This means that
         * we want to bind a function to an event (update
         * world). This is done using [1]. You can get the
         * inference from [2]
         * 
         * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1event_1_1Events.html#a0c8c7e6a33ad46f8be45b6a33d279fdc
         * [2]: http://gazebosim.org/tutorials?tut=plugins_model&cat=write_plugin#Code
         */
        this->update_connection = event::Events::ConnectWorldUpdateBegin(
            boost::bind(&GazeboRosSlbotController::UpdateChild, this)); // Bind this->UpdateChild
        // ---- End: Setup things specific to this plugin ----
    }

    // Update child
    void GazeboRosSlbotController::UpdateChild() {
        // Get the current simulation time
        /*
         * This returns the time since the start
         * of simulation. Use SimTime to get the
         * time since the start of simulation [1].
         * Use common::Time::GetWallTime for real
         * world time [2].
         * 
         * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1World.html#ae8de96cafe2517f4285edb421ab130e7
         * [2]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1common_1_1Time.html#aa8e053e14c4d1170ef45e5d9e0a26d10
         */
        common::Time curr_time = this->world->SimTime();
        if ((curr_time - this->params.last_update_time).Double() > this->params.update_period_sec) {
            // ---- Update the child (according to the rate) ----
            this->PublishJointAngle();  // Joint angle published
            this->ControllerLoop(); // PID controller
        }
    }

    // Publish joint angle
    void GazeboRosSlbotController::PublishJointAngle() {
        // Get joint angle
        /*
         * Get the joint angle in Gazebo simulation.
         * This is retrieved from the JointPtr which
         * was obtained from ModelPtr. Position function
         * gets the floating point value [1], which is
         * rotation in radians or translation in meters
         * 
         * [1]: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1physics_1_1Joint.html#a1e48139677005b6702c8c00832710da2
         */
        double jangle_rad = this->joint->Position(0);
        // Update the publishing message
        this->params.js_msg.header.seq += 1;
        this->params.js_msg.header.stamp = ros::Time::now();    // Messages in ROS time
        this->params.js_msg.name.clear();
        this->params.js_msg.name.push_back(this->params.joint_name);
        this->params.js_msg.position.clear();
        this->params.js_msg.position.push_back(jangle_rad);
        // Publish the message (for joint angle)
        this->joint_angle_publisher_.publish(this->params.js_msg);  // Publish
        // ---- Child updated ----
        // Update the last updated time
        this->params.last_update_time += common::Time(this->params.update_period_sec);
    }

    // Controller loop for the joint
    void GazeboRosSlbotController::ControllerLoop() {
        // Lock the mutex (scoped lock)
        /*
         * This will allow the lock to be enabled
         * throughout the scope of this function.
         * The scoped lock [1] persists throughout
         * the scope of declaration.
         * 
         * [1]: https://www.boost.org/doc/libs/1_76_0/doc/html/thread/synchronization.html
         * [2]: https://www.boost.org/doc/libs/1_31_0/libs/thread/doc/mutex.html
         */
        boost::mutex::scoped_lock(this->controller.lock);
        // PID controller
        double curr_pos = this->joint->Position(0); // Current position
        // Applied torque
        double error = (curr_pos - this->controller.desired_pos);
        double kp_part = -this->controller.kp * (error);
        double kd_part = -this->controller.kd * (this->joint->GetVelocity(0));
        double applied_torque = kp_part + kd_part;
        this->joint->SetForce(0, applied_torque);   // Apply torque
    }

    // Callback queue thread
    void GazeboRosSlbotController::QueueThread() {
        double timeout = 0.01;
        while (this->is_alive && this->_nh->ok()) {
            // Call callbacks on the queue
            /*
             * The callAvailable function [1] is used to call the
             * queued callbacks. It is given a WallDuration [2] as 
             * timeout, in case execution of this thread isn't held
             * for long.
             * 
             * [1]: http://docs.ros.org/en/latest/api/roscpp/html/classros_1_1CallbackQueue.html#a82c2abb2c11a7bf90e7ee46625e24eeb
             * [2]: http://docs.ros.org/en/latest/api/rostime/html/classros_1_1WallDuration.html
             */
            this->queue_.callAvailable(ros::WallDuration(timeout));
        }
    }

    // New position callback
    void GazeboRosSlbotController::SetNewTarget(const std_msgs::Float64::ConstPtr& npos) {
        // Lock the mutex for this callback
        boost::mutex::scoped_lock(this->controller.lock);
        this->controller.desired_pos = npos->data;
    }

    // Set controller parameters (service server)
    bool GazeboRosSlbotController::SetController(
            control_toolbox::SetPidGainsRequest &req, 
            control_toolbox::SetPidGainsResponse &res) {
        // Verify that the request is valid
        if (req.d < 0) {    // Damping shouldn't be negative
            return false;
        }
        // Lock the mutex for the service server
        boost::mutex::scoped_lock(this->controller.lock);
        // Set the parameters
        this->controller.kp = req.p;
        this->controller.kd = req.d;
        ROS_INFO_NAMED("slbot", "GazeboSlbotController Plugin (ns = %s) Controller gains: P = %f, D = %f",
            this->robot_namespace.c_str(), this->controller.kp, this->controller.kd);
        return true;
    }
}
